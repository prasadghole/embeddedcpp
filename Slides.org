#+Title: Embedded C++ 
# +Author: Prasad Ghole
#+Email: prasad.ghole@ltts.com
#+REVEAL_THEME: night
#+OPTIONS: toc:nil num:nil timestamp:nil 
* Introduction to C++
* Devlopment tools


 | Vendor | C++ Standard |
 |--------+--------------|
 | Keil   | C++11        |
 | ARM    | C++14        |
 | IAR    | C++14        |
 | GCC    | C++17        |
* Evaluation Boards
** Nucleo-F767ZI
   [[./images/nucleo-f767.png]]
** Features
  1. 3 User LED
  2. On board ST Link extension board for easy debugging
  3. Mass storage
  4. Virtual COM port
  5. Flexible power supply options
  6. Ethrnet RJ45
** Nucleo-F303RE
   [[./images/nucleo-f303.png]]
** Features
  1. 1 User LED
  2. On board ST Link extension board for easy debugging
  3. Mass storage
  4. Virtual COM port
  5. Flexible power supply options
* Debug Tools
** OpenOCD and STM GDB server
[[http://openocd.org/doc/html/index.html]]

OpenOCD is a Open On-Chip debugger that provides programming,debugging  boudry-scan
testing for embedded device. It acts as a server and acceptss incoming
connection from GDB via port 3333 or telnet port 4444.
*** Setup
[[./images/debugserver.png]]

* stlink 
** WARNING
Please make sure not to connect both external 5 volts power supply and USB power supply at same time.
** ST link usb drive
Download usb driver from 
https://my.st.com/content/my_st_com/en/products/development-tools/software-development-tools/stm32-software-development-tools/stm32-utilities/stsw-link009.license=1564137466456.product=STSW-LINK009.version=2.0.1.html
 Run stlink_winusb_install batch file to install driver.
** ST link utilities
Download st link utility from 
https://my.st.com/content/my_st_com/en/products/development-tools/software-development-tools/stm32-software-development-tools/stm32-programmers/stsw-link004.html

* Installing GCC cross compiler
1. Go to the https://developer.arm.com 
2. Click on Tools and software >> Open source Software >> GNU toolchain
#+REVEAL: split
3. Downlaod ARM GNU embedded toolchain as per your host platform (only 32 bit toolchains are available now)
https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads

* Verify installation
  
#+BEGIN_SRC shell :exports code :eval yes

arm-none-eabi-g++ --version
 
#+END_SRC
* Hello World
We will write hello world program which will print "Hello World of C++ " sting to serial port using micro controller UART3.

#+BEGIN_NOTES
Explain virtual com port.
#+END_NOTES

* Build
*** Write Program
*** Compiling
*** Linking
* Flash 
** Converting to binary
ELf file consists of additional header information but to load binary on target flash we need to strip down this 
additional information. 
#+BEGIN_SRC shell

arm-none-eabi-objcopy -I elf -O binary firmware.elf firmware.bin
 
#+END_SRC
** Programming Controller

#+BEGIN_SRC bash
st-link_cli -C SWD -P firmware.bin 0x8000000 -V "after_programming"
#+END_SRC
* Debug
** Start debug server
** load elf
** Debug
* Use namespece
Explain how we can use namespace to simplify naming of common static functions.

#+SRC_BEGIN C++

#+SRC_END

* Strongly typed
** enum class
* Function Inline
  Macros can be replaced with strongly typed
* Type Conversions
** dynamic_cast
** reinterpret_cast
** static_cast
** const_cast
* static asserts 
This will help in compile time catching of errors.
* scoped enums
An enumeration is a distinct type whose values are restricted to a range of values.
Intenally enumerations are of integer type. But C++ enumeration are more strongly typed compared to C. In C enum and interger are 
interchangeble but in C++ not unless explicitly casted.
** Size of enumerations
Starting from C++ 11 we can now tell compiler to allocate specific size of enumerations constans. This will help in communication 
protocols parser we can directly use enumerations values in transmit or recieve buffer.

#+BEGIN_SRC  C
#include <stdio.h>
enum command { ON, OFF};
enum command c;

int main ()
{
  printf ("Hello World %d",sizeof(c));

  return 0;
}

#+END_SRC

** Size of scoped enumerations
#+BEGIN_SRC C++ 
#include <iostream>

enum class command : char { ON, OFF};
enum class functioncode : short { READ, WRTE, UPDATE };

int main ()
{
  std::cout << "scoped enum with size for command = "
  << sizeof(command) << std::endl ;
  std::cout << "scoped enum with size for functioncode = "
 << sizeof(functioncode) << std::endl ;
  return 0;
}
#+END_SRC
[[https://onlinegdb.com/BkplLLN4r][code]]
* User defined literals
** Temperature conversion
* Delete functions
For specific device classes we don't want to create duplicate copy of same peripheral object. 
We can make sure nobody can accidently copy object we will delete copy constructor.

#+BEGIN_SRC

#+END_SRC

* Declaring function pointers


#+BEGIN_SRC
typedef bool (*Transmit)(char *);

using Transmit = bool(*)(char *);
#+END_SRC


* Mixing C and C++  libraries
C++ compiler will use name mangeling hence functions name used by user will have diffrent name for compiler. Hence if you
 want to use a function from C library we should tell compiler not to change its name by telling compiler for C linkage.

#+BEGIN_SRC
extern int C_library_function(void);
#+END_SRC 

To do this on entire header file with exported functions we can used

#+BEGIN_SRC

extern int C_library_function(void);
#+END_SRC 

* Templates
* std::Array
* std::tuple
* Referances
** Gnu C 
*** Predefined macros
https://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html
** Keil library
*** run time library support 
http://www.keil.com/support/man/docs/armlib/armlib_chr1358938908603.htm

C++ libraries need C libraries for target specific support.
